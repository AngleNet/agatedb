// This file is generated by rust-protobuf 2.10.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `meta.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct KV {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub user_meta: ::std::vec::Vec<u8>,
    pub version: u64,
    pub expires_at: u64,
    pub meta: ::std::vec::Vec<u8>,
    pub stream_id: u32,
    pub stream_done: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KV {
    fn default() -> &'a KV {
        <KV as ::protobuf::Message>::default_instance()
    }
}

impl KV {
    pub fn new() -> KV {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes user_meta = 3;


    pub fn get_user_meta(&self) -> &[u8] {
        &self.user_meta
    }
    pub fn clear_user_meta(&mut self) {
        self.user_meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_meta(&mut self, v: ::std::vec::Vec<u8>) {
        self.user_meta = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_meta(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.user_meta
    }

    // Take field
    pub fn take_user_meta(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.user_meta, ::std::vec::Vec::new())
    }

    // uint64 version = 4;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // uint64 expires_at = 5;


    pub fn get_expires_at(&self) -> u64 {
        self.expires_at
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: u64) {
        self.expires_at = v;
    }

    // bytes meta = 6;


    pub fn get_meta(&self) -> &[u8] {
        &self.meta
    }
    pub fn clear_meta(&mut self) {
        self.meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: ::std::vec::Vec<u8>) {
        self.meta = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meta(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.meta
    }

    // Take field
    pub fn take_meta(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.meta, ::std::vec::Vec::new())
    }

    // uint32 stream_id = 10;


    pub fn get_stream_id(&self) -> u32 {
        self.stream_id
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: u32) {
        self.stream_id = v;
    }

    // bool stream_done = 11;


    pub fn get_stream_done(&self) -> bool {
        self.stream_done
    }
    pub fn clear_stream_done(&mut self) {
        self.stream_done = false;
    }

    // Param is passed by value, moved
    pub fn set_stream_done(&mut self, v: bool) {
        self.stream_done = v;
    }
}

impl ::protobuf::Message for KV {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.user_meta)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expires_at = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.meta)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stream_id = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream_done = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if !self.user_meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.user_meta);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expires_at != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expires_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.meta);
        }
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::value_size(10, self.stream_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stream_done != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if !self.user_meta.is_empty() {
            os.write_bytes(3, &self.user_meta)?;
        }
        if self.version != 0 {
            os.write_uint64(4, self.version)?;
        }
        if self.expires_at != 0 {
            os.write_uint64(5, self.expires_at)?;
        }
        if !self.meta.is_empty() {
            os.write_bytes(6, &self.meta)?;
        }
        if self.stream_id != 0 {
            os.write_uint32(10, self.stream_id)?;
        }
        if self.stream_done != false {
            os.write_bool(11, self.stream_done)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KV {
        KV::new()
    }

    fn default_instance() -> &'static KV {
        static mut instance: ::protobuf::lazy::Lazy<KV> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KV,
        };
        unsafe {
            instance.get(KV::new)
        }
    }
}

impl ::protobuf::Clear for KV {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.user_meta.clear();
        self.version = 0;
        self.expires_at = 0;
        self.meta.clear();
        self.stream_id = 0;
        self.stream_done = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for KV {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct KVList {
    // message fields
    pub kv: ::protobuf::RepeatedField<KV>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KVList {
    fn default() -> &'a KVList {
        <KVList as ::protobuf::Message>::default_instance()
    }
}

impl KVList {
    pub fn new() -> KVList {
        ::std::default::Default::default()
    }

    // repeated .meta.KV kv = 1;


    pub fn get_kv(&self) -> &[KV] {
        &self.kv
    }
    pub fn clear_kv(&mut self) {
        self.kv.clear();
    }

    // Param is passed by value, moved
    pub fn set_kv(&mut self, v: ::protobuf::RepeatedField<KV>) {
        self.kv = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kv(&mut self) -> &mut ::protobuf::RepeatedField<KV> {
        &mut self.kv
    }

    // Take field
    pub fn take_kv(&mut self) -> ::protobuf::RepeatedField<KV> {
        ::std::mem::replace(&mut self.kv, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for KVList {
    fn is_initialized(&self) -> bool {
        for v in &self.kv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kv {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kv {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KVList {
        KVList::new()
    }

    fn default_instance() -> &'static KVList {
        static mut instance: ::protobuf::lazy::Lazy<KVList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KVList,
        };
        unsafe {
            instance.get(KVList::new)
        }
    }
}

impl ::protobuf::Clear for KVList {
    fn clear(&mut self) {
        self.kv.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for KVList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ManifestChangeSet {
    // message fields
    pub changes: ::protobuf::RepeatedField<ManifestChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ManifestChangeSet {
    fn default() -> &'a ManifestChangeSet {
        <ManifestChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ManifestChangeSet {
    pub fn new() -> ManifestChangeSet {
        ::std::default::Default::default()
    }

    // repeated .meta.ManifestChange changes = 1;


    pub fn get_changes(&self) -> &[ManifestChange] {
        &self.changes
    }
    pub fn clear_changes(&mut self) {
        self.changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_changes(&mut self, v: ::protobuf::RepeatedField<ManifestChange>) {
        self.changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changes(&mut self) -> &mut ::protobuf::RepeatedField<ManifestChange> {
        &mut self.changes
    }

    // Take field
    pub fn take_changes(&mut self) -> ::protobuf::RepeatedField<ManifestChange> {
        ::std::mem::replace(&mut self.changes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ManifestChangeSet {
    fn is_initialized(&self) -> bool {
        for v in &self.changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.changes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.changes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ManifestChangeSet {
        ManifestChangeSet::new()
    }

    fn default_instance() -> &'static ManifestChangeSet {
        static mut instance: ::protobuf::lazy::Lazy<ManifestChangeSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ManifestChangeSet,
        };
        unsafe {
            instance.get(ManifestChangeSet::new)
        }
    }
}

impl ::protobuf::Clear for ManifestChangeSet {
    fn clear(&mut self) {
        self.changes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ManifestChangeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ManifestChange {
    // message fields
    pub Id: u64,
    pub Op: ManifestChange_Operation,
    pub Level: u32,
    pub key_id: u64,
    pub encryption_algo: EncryptionAlgo,
    pub compression: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ManifestChange {
    fn default() -> &'a ManifestChange {
        <ManifestChange as ::protobuf::Message>::default_instance()
    }
}

impl ManifestChange {
    pub fn new() -> ManifestChange {
        ::std::default::Default::default()
    }

    // uint64 Id = 1;


    pub fn get_Id(&self) -> u64 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: u64) {
        self.Id = v;
    }

    // .meta.ManifestChange.Operation Op = 2;


    pub fn get_Op(&self) -> ManifestChange_Operation {
        self.Op
    }
    pub fn clear_Op(&mut self) {
        self.Op = ManifestChange_Operation::CREATE;
    }

    // Param is passed by value, moved
    pub fn set_Op(&mut self, v: ManifestChange_Operation) {
        self.Op = v;
    }

    // uint32 Level = 3;


    pub fn get_Level(&self) -> u32 {
        self.Level
    }
    pub fn clear_Level(&mut self) {
        self.Level = 0;
    }

    // Param is passed by value, moved
    pub fn set_Level(&mut self, v: u32) {
        self.Level = v;
    }

    // uint64 key_id = 4;


    pub fn get_key_id(&self) -> u64 {
        self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: u64) {
        self.key_id = v;
    }

    // .meta.EncryptionAlgo encryption_algo = 5;


    pub fn get_encryption_algo(&self) -> EncryptionAlgo {
        self.encryption_algo
    }
    pub fn clear_encryption_algo(&mut self) {
        self.encryption_algo = EncryptionAlgo::aes;
    }

    // Param is passed by value, moved
    pub fn set_encryption_algo(&mut self, v: EncryptionAlgo) {
        self.encryption_algo = v;
    }

    // uint32 compression = 6;


    pub fn get_compression(&self) -> u32 {
        self.compression
    }
    pub fn clear_compression(&mut self) {
        self.compression = 0;
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: u32) {
        self.compression = v;
    }
}

impl ::protobuf::Message for ManifestChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Op, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Level = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.key_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_algo, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.compression = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Op != ManifestChange_Operation::CREATE {
            my_size += ::protobuf::rt::enum_size(2, self.Op);
        }
        if self.Level != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.key_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.encryption_algo != EncryptionAlgo::aes {
            my_size += ::protobuf::rt::enum_size(5, self.encryption_algo);
        }
        if self.compression != 0 {
            my_size += ::protobuf::rt::value_size(6, self.compression, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_uint64(1, self.Id)?;
        }
        if self.Op != ManifestChange_Operation::CREATE {
            os.write_enum(2, self.Op.value())?;
        }
        if self.Level != 0 {
            os.write_uint32(3, self.Level)?;
        }
        if self.key_id != 0 {
            os.write_uint64(4, self.key_id)?;
        }
        if self.encryption_algo != EncryptionAlgo::aes {
            os.write_enum(5, self.encryption_algo.value())?;
        }
        if self.compression != 0 {
            os.write_uint32(6, self.compression)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ManifestChange {
        ManifestChange::new()
    }

    fn default_instance() -> &'static ManifestChange {
        static mut instance: ::protobuf::lazy::Lazy<ManifestChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ManifestChange,
        };
        unsafe {
            instance.get(ManifestChange::new)
        }
    }
}

impl ::protobuf::Clear for ManifestChange {
    fn clear(&mut self) {
        self.Id = 0;
        self.Op = ManifestChange_Operation::CREATE;
        self.Level = 0;
        self.key_id = 0;
        self.encryption_algo = EncryptionAlgo::aes;
        self.compression = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ManifestChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ManifestChange_Operation {
    CREATE = 0,
    DELETE = 1,
}

impl ::protobuf::ProtobufEnum for ManifestChange_Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ManifestChange_Operation> {
        match value {
            0 => ::std::option::Option::Some(ManifestChange_Operation::CREATE),
            1 => ::std::option::Option::Some(ManifestChange_Operation::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ManifestChange_Operation] = &[
            ManifestChange_Operation::CREATE,
            ManifestChange_Operation::DELETE,
        ];
        values
    }
}

impl ::std::marker::Copy for ManifestChange_Operation {
}

impl ::std::default::Default for ManifestChange_Operation {
    fn default() -> Self {
        ManifestChange_Operation::CREATE
    }
}

impl ::protobuf::reflect::ProtobufValue for ManifestChange_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockOffset {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub offset: u32,
    pub len: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockOffset {
    fn default() -> &'a BlockOffset {
        <BlockOffset as ::protobuf::Message>::default_instance()
    }
}

impl BlockOffset {
    pub fn new() -> BlockOffset {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // uint32 offset = 2;


    pub fn get_offset(&self) -> u32 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = v;
    }

    // uint32 len = 3;


    pub fn get_len(&self) -> u32 {
        self.len
    }
    pub fn clear_len(&mut self) {
        self.len = 0;
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = v;
    }
}

impl ::protobuf::Message for BlockOffset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.len != 0 {
            my_size += ::protobuf::rt::value_size(3, self.len, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if self.offset != 0 {
            os.write_uint32(2, self.offset)?;
        }
        if self.len != 0 {
            os.write_uint32(3, self.len)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockOffset {
        BlockOffset::new()
    }

    fn default_instance() -> &'static BlockOffset {
        static mut instance: ::protobuf::lazy::Lazy<BlockOffset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockOffset,
        };
        unsafe {
            instance.get(BlockOffset::new)
        }
    }
}

impl ::protobuf::Clear for BlockOffset {
    fn clear(&mut self) {
        self.key.clear();
        self.offset = 0;
        self.len = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockOffset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TableIndex {
    // message fields
    pub offsets: ::protobuf::RepeatedField<BlockOffset>,
    pub bloom_filter: ::std::vec::Vec<u8>,
    pub estimated_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableIndex {
    fn default() -> &'a TableIndex {
        <TableIndex as ::protobuf::Message>::default_instance()
    }
}

impl TableIndex {
    pub fn new() -> TableIndex {
        ::std::default::Default::default()
    }

    // repeated .meta.BlockOffset offsets = 1;


    pub fn get_offsets(&self) -> &[BlockOffset] {
        &self.offsets
    }
    pub fn clear_offsets(&mut self) {
        self.offsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_offsets(&mut self, v: ::protobuf::RepeatedField<BlockOffset>) {
        self.offsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offsets(&mut self) -> &mut ::protobuf::RepeatedField<BlockOffset> {
        &mut self.offsets
    }

    // Take field
    pub fn take_offsets(&mut self) -> ::protobuf::RepeatedField<BlockOffset> {
        ::std::mem::replace(&mut self.offsets, ::protobuf::RepeatedField::new())
    }

    // bytes bloom_filter = 2;


    pub fn get_bloom_filter(&self) -> &[u8] {
        &self.bloom_filter
    }
    pub fn clear_bloom_filter(&mut self) {
        self.bloom_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_bloom_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.bloom_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bloom_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bloom_filter
    }

    // Take field
    pub fn take_bloom_filter(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bloom_filter, ::std::vec::Vec::new())
    }

    // uint64 estimated_size = 3;


    pub fn get_estimated_size(&self) -> u64 {
        self.estimated_size
    }
    pub fn clear_estimated_size(&mut self) {
        self.estimated_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_estimated_size(&mut self, v: u64) {
        self.estimated_size = v;
    }
}

impl ::protobuf::Message for TableIndex {
    fn is_initialized(&self) -> bool {
        for v in &self.offsets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offsets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bloom_filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.estimated_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.offsets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.bloom_filter.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.bloom_filter);
        }
        if self.estimated_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.estimated_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.offsets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.bloom_filter.is_empty() {
            os.write_bytes(2, &self.bloom_filter)?;
        }
        if self.estimated_size != 0 {
            os.write_uint64(3, self.estimated_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableIndex {
        TableIndex::new()
    }

    fn default_instance() -> &'static TableIndex {
        static mut instance: ::protobuf::lazy::Lazy<TableIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TableIndex,
        };
        unsafe {
            instance.get(TableIndex::new)
        }
    }
}

impl ::protobuf::Clear for TableIndex {
    fn clear(&mut self) {
        self.offsets.clear();
        self.bloom_filter.clear();
        self.estimated_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TableIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Checksum {
    // message fields
    pub algo: Checksum_Algorithm,
    pub sum: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Checksum {
    fn default() -> &'a Checksum {
        <Checksum as ::protobuf::Message>::default_instance()
    }
}

impl Checksum {
    pub fn new() -> Checksum {
        ::std::default::Default::default()
    }

    // .meta.Checksum.Algorithm algo = 1;


    pub fn get_algo(&self) -> Checksum_Algorithm {
        self.algo
    }
    pub fn clear_algo(&mut self) {
        self.algo = Checksum_Algorithm::CRC32C;
    }

    // Param is passed by value, moved
    pub fn set_algo(&mut self, v: Checksum_Algorithm) {
        self.algo = v;
    }

    // uint64 sum = 2;


    pub fn get_sum(&self) -> u64 {
        self.sum
    }
    pub fn clear_sum(&mut self) {
        self.sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: u64) {
        self.sum = v;
    }
}

impl ::protobuf::Message for Checksum {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.algo, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.algo != Checksum_Algorithm::CRC32C {
            my_size += ::protobuf::rt::enum_size(1, self.algo);
        }
        if self.sum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.algo != Checksum_Algorithm::CRC32C {
            os.write_enum(1, self.algo.value())?;
        }
        if self.sum != 0 {
            os.write_uint64(2, self.sum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Checksum {
        Checksum::new()
    }

    fn default_instance() -> &'static Checksum {
        static mut instance: ::protobuf::lazy::Lazy<Checksum> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Checksum,
        };
        unsafe {
            instance.get(Checksum::new)
        }
    }
}

impl ::protobuf::Clear for Checksum {
    fn clear(&mut self) {
        self.algo = Checksum_Algorithm::CRC32C;
        self.sum = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Checksum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Checksum_Algorithm {
    CRC32C = 0,
    XXHash64 = 1,
}

impl ::protobuf::ProtobufEnum for Checksum_Algorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Checksum_Algorithm> {
        match value {
            0 => ::std::option::Option::Some(Checksum_Algorithm::CRC32C),
            1 => ::std::option::Option::Some(Checksum_Algorithm::XXHash64),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Checksum_Algorithm] = &[
            Checksum_Algorithm::CRC32C,
            Checksum_Algorithm::XXHash64,
        ];
        values
    }
}

impl ::std::marker::Copy for Checksum_Algorithm {
}

impl ::std::default::Default for Checksum_Algorithm {
    fn default() -> Self {
        Checksum_Algorithm::CRC32C
    }
}

impl ::protobuf::reflect::ProtobufValue for Checksum_Algorithm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DataKey {
    // message fields
    pub key_id: u64,
    pub data: ::std::vec::Vec<u8>,
    pub iv: ::std::vec::Vec<u8>,
    pub created_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataKey {
    fn default() -> &'a DataKey {
        <DataKey as ::protobuf::Message>::default_instance()
    }
}

impl DataKey {
    pub fn new() -> DataKey {
        ::std::default::Default::default()
    }

    // uint64 key_id = 1;


    pub fn get_key_id(&self) -> u64 {
        self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: u64) {
        self.key_id = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes iv = 3;


    pub fn get_iv(&self) -> &[u8] {
        &self.iv
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.iv
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.iv, ::std::vec::Vec::new())
    }

    // int64 created_at = 4;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }
}

impl ::protobuf::Message for DataKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.key_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.iv)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.created_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.iv.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.iv);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key_id != 0 {
            os.write_uint64(1, self.key_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.iv.is_empty() {
            os.write_bytes(3, &self.iv)?;
        }
        if self.created_at != 0 {
            os.write_int64(4, self.created_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataKey {
        DataKey::new()
    }

    fn default_instance() -> &'static DataKey {
        static mut instance: ::protobuf::lazy::Lazy<DataKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataKey,
        };
        unsafe {
            instance.get(DataKey::new)
        }
    }
}

impl ::protobuf::Clear for DataKey {
    fn clear(&mut self) {
        self.key_id = 0;
        self.data.clear();
        self.iv.clear();
        self.created_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DataKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncryptionAlgo {
    aes = 0,
}

impl ::protobuf::ProtobufEnum for EncryptionAlgo {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptionAlgo> {
        match value {
            0 => ::std::option::Option::Some(EncryptionAlgo::aes),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncryptionAlgo] = &[
            EncryptionAlgo::aes,
        ];
        values
    }
}

impl ::std::marker::Copy for EncryptionAlgo {
}

impl ::std::default::Default for EncryptionAlgo {
    fn default() -> Self {
        EncryptionAlgo::aes
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionAlgo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}
